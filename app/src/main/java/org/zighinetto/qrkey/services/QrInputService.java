package org.zighinetto.qrkey.services;

import android.content.Context;
import android.graphics.ImageFormat;
import android.hardware.camera2.CameraAccessException;
import android.hardware.camera2.CameraCaptureSession;
import android.hardware.camera2.CameraCharacteristics;
import android.hardware.camera2.CameraDevice;
import android.hardware.camera2.CameraManager;
import android.hardware.camera2.CaptureRequest;
import android.hardware.camera2.params.StreamConfigurationMap;
import android.inputmethodservice.InputMethodService;
import android.media.ImageReader;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.util.Log;
import android.util.Size;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.inputmethod.EditorInfo;

import com.google.zxing.qrcode.QRCodeReader;

import org.zighinetto.qrkey.R;

import com.google.zxing.Reader;

import java.util.Collections;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class QrInputService extends InputMethodService {

    private SurfaceView mCameraPreview;
    private SurfaceHolder mCameraHolder;

    private Reader qrReader;
    private CameraDevice mCamera;
    private CameraManager mCameraManager;

    private String defaultCameraId = null, selectedCameraId;

    private float cameraImageProportions;


    /**
     * This a callback object for the {@link ImageReader}. "onImageAvailable" will be called when a
     * still image is ready to be saved.
     */
    private final ImageReader.OnImageAvailableListener mOnImageAvailableListener
            = new ImageReader.OnImageAvailableListener() {

        @Override
        public void onImageAvailable(ImageReader reader) {
            // TODO
            mCameraHandler.post(null);
        }

    };

    /**
     * {@link CaptureRequest.Builder} for the camera preview
     */
    private CaptureRequest.Builder mPreviewRequestBuilder;

    /**
     * {@link CaptureRequest} generated by {@link #mPreviewRequestBuilder}
     */
    private CaptureRequest mPreviewRequest;


    /**
     * A {@link Semaphore} to prevent the app from exiting before closing the camera.
     */
    private Semaphore mCameraOpenCloseLock = new Semaphore(1);

    private Handler mCameraHandler;
    private HandlerThread mHandlerThread;
    private CameraCaptureSession mCaptureSession;


    @Override
    public void onCreate() {
        super.onCreate();
        qrReader = new QRCodeReader();

        selectedCameraId = null;
    }


    @Override
    public void onStartInput(EditorInfo attribute, boolean restarting) {
        super.onStartInput(attribute, restarting);

        mCameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);
        mHandlerThread = new HandlerThread("CameraHandler");
        mCameraHandler = new Handler(mHandlerThread.getLooper());

        //Scan cameras. Choose default (preference) camera or first rear camera
        try {
            for (String cameraId : mCameraManager.getCameraIdList()) {

                if (cameraId.equals(this.defaultCameraId)) {
                    selectedCameraId = cameraId;
                    break;
                }

                CameraCharacteristics characteristics = mCameraManager.getCameraCharacteristics(cameraId);
                if (characteristics.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_BACK || selectedCameraId == null) {
                    selectedCameraId = cameraId;
                    break;
                }
            }
        } catch (CameraAccessException e) {
            Log.e(getClass().getSimpleName(), "Camera error: " + e.getMessage(), e);
            throw new RuntimeException(e);
        }


        if (selectedCameraId == null) throw new RuntimeException("No camera chosen");

        try {
            CameraCharacteristics characteristics = mCameraManager.getCameraCharacteristics(selectedCameraId);

            StreamConfigurationMap configs = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);
            Size[] sizes = configs.getOutputSizes(ImageFormat.NV21);


            if (!mCameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
                throw new RuntimeException("Time out waiting to lock camera opening.");
            }
            mCameraManager.openCamera(selectedCameraId, new CameraCallback(), mCameraHandler);

        } catch (InterruptedException e) {
            throw new RuntimeException("Interrupted while trying to lock camera opening.", e);
        } catch (CameraAccessException e) {
            Log.e(getClass().getSimpleName(), "Camera error: " + e.getMessage(), e);
            throw new RuntimeException(e);
        }
    }


    @Override
    public void onDestroy() {
        qrReader = null;

        super.onDestroy();
    }

    @Override
    public void onFinishInputView(boolean finishingInput) {

        try {
            mCameraOpenCloseLock.acquire();
            if (null != mCaptureSession) {
                mCaptureSession.close();
                mCaptureSession = null;
            }
            if (null != mCamera) {
                mCamera.close();
                mCamera = null;
            }
            /*
            if (null != mImageReader) {
                mImageReader.close();
                mImageReader = null;
            }*/
        } catch (InterruptedException e) {
            throw new RuntimeException("Interrupted while trying to lock camera closing.", e);
        } finally {
            mCameraOpenCloseLock.release();
        }

        mHandlerThread.quitSafely();
        try {
            mHandlerThread.join();
            mHandlerThread = null;
            mCameraHandler = null;
        } catch (InterruptedException e) {
            Log.v(getClass().getSimpleName(), e.getMessage(), e);
        }

        super.onFinishInputView(finishingInput);
    }

    @Override
    public View onCreateInputView() {

        try {
            CameraCharacteristics characteristics = mCameraManager.getCameraCharacteristics(selectedCameraId);
            StreamConfigurationMap configs = characteristics.get(
                    CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);

        } catch (CameraAccessException ex) {
            Log.e(getClass().getSimpleName(), "Error accessing locked camera", ex);
            throw new RuntimeException(ex);
        }

        View kbw = getLayoutInflater().inflate(R.layout.ime, null);

        mCameraPreview = (SurfaceView) kbw.findViewById(R.id.ime_camera_preview);
        mCameraHolder = mCameraPreview.getHolder();
        //mCameraHolder.addCallback(this);
        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.HONEYCOMB)
            //noinspection deprecation
            mCameraHolder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);

        return kbw;
    }

    @Override
    public void onStartInputView(EditorInfo info, boolean restarting) {
        super.onStartInputView(info, restarting);


        try {
            mCamera.createCaptureSession(Collections.singletonList(this.mCameraHolder.getSurface()), new SessionCallback(), mCameraHandler);
        } catch (CameraAccessException e) {
            Log.e(getClass().getSimpleName(), "Unable to start input view", e);
            throw new RuntimeException(e);
        }

    }

    private final class CameraCallback extends CameraDevice.StateCallback {

        @Override
        public void onOpened(CameraDevice cameraDevice) {
            // This method is called when the camera is opened.  We start camera preview here.
            mCameraOpenCloseLock.release();
            QrInputService.this.mCamera = cameraDevice;
            //createCameraPreviewSession();
        }

        @Override
        public void onDisconnected(CameraDevice cameraDevice) {
            mCameraOpenCloseLock.release();
            cameraDevice.close();
            mCamera = null;
        }

        @Override
        public void onError(CameraDevice cameraDevice, int error) {
            mCameraOpenCloseLock.release();
            cameraDevice.close();
            //mCameraDevice = null;
        /*Activity activity = getActivity();
        if (null != activity) {
            activity.finish();
        }*/
        }

    }

    protected final class SessionCallback extends CameraCaptureSession.StateCallback {
        @Override
        public void onConfigured(CameraCaptureSession session) {
            QrInputService.this.mCaptureSession = session;
        }

        @Override
        public void onConfigureFailed(CameraCaptureSession session) {

        }
    }
}
